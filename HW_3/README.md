# Домашнее Задание 3 по Системам Баз Данных

## Скачать большой Датасет и замерить скорость импорта

Для теста был выбран датасет фильмов из IMDB(файл: [data.tsv](./HW_3/data.tsv)). Он сдержит порядка 9 милионов записей, но для тестов использовались лишь первые 3 миллиона. Для benchmark'а использовался **Python** с использованием библиотек **redis**, **сsv** и **time**.  
Пример кода с использованием библиотеки **redis**:

```Python
import redis

redis_pool = redis.ConnectionPool(host='localhost', port=6379, db=0)
r = redis.Redis(connection_pool=pool)

redis.set('mykey', 'Hello from Python!')
value = redis.get('mykey')
print(value)

redis.zadd('vehicles', {'car' : 0})
redis.zadd('vehicles', {'bike' : 0})
vehicles = redis.zrange('vehicles', 0, -1)
print(vehicles)
```

Для тестирования выполнялись следующие шаги:  
1) ```console
    foo@bar:~$ python time_test.py 
    ```
2) Внутри **redis-cli**(`foo@bar:~$ redis-cli -h hostname -p port`): FLUSHDB
   
  
Результаты тестирования следующие:
| Test id       | Import time(sec) | FLUSHDB time(sec)|
| ------------- |:----------------:| ---------------: |
| 1             | 76.2064979076    |           1.21   |
| 2             | 75.8912879101    |           1.22   |
| 3             | 76.4235001200    |           1.19   |
| 4             | 76.1028717802    |           1.19   |
| 5             | 76.5069380012    |           1.20   |

## Настроить редис кластер на 3х нодах с отказоустойчивостью

Начнём с того что делать это дело довольно не тривиальное и в первый раз было довольно трудно(**ОЧЕНЬ ТРУДНО**).  
Для развертывания кластера использовалась система **arch**, с установленными **docker**, **docker-machine**, **virtualbox-host-modules-arch**.  
  
Сначала с помощью **docker-machine** было создано 6 ноды($master$, 2x $slave$). И уже на этом этапе у меня появились проблемы, я никогда не ставил виртуалки, и у меня блин **ARCH**. В общем потратив около 5 часов на решение проблем с созданием **docker-machine**. У меня вроде получилось починить **VirtualBox** и подружить с **docker-machine**(есть смутное ощущение что на винде я бы таких страдиний не испытвал).  
  
Далее 2 шаг, создать **docker swarm**, к счастью тут все прошло гладко, просто инициализируем **swarm** на ноде $master$:
```console
$ docker swarm init --advertise-addr master_node_ip_address
```
Получаем в ответ что-то типа:
```console
docker swarm join --token SWMTKN-1-2wb0sivbsxsx0t3va8wv0qywa303q1mcc2syplrwj0q1301kfs-8qfc9yhwst06y8c1gusftrjkl master_node_ip_address:port
```
Эту команду выполняем на $slave$ нодах, что бы добавить их в **swarm**.

Ура, 30% работы выполнено.

Далее не лучше...

Ставим на каждую ноду **redis**. И настраиваем *redis.conf*([google](https://google.com) в помощь). Для соединения будем использовать **tcl**, поэтому биндимся на ring(0.0.0.0) настраиваем порты(для мастера стандартный порт редиса 6379), таймауты(я ставил 5000 ms), количество реплик(у меня 1) и по желанию logfile, так же для $slave$ нод указываем мастера. Т.к. ноды всего 3, в $slave$ нодах сервис **redis-server** буде запускать как **sentinel**.   
  
В целом, на этом всё. Дальше поддключаемся через $maseter$ ноду, например использую redis-cli и пользуемся как обыным redis.

P.S. Можно было сделать проще, но там не совсем честно:
запустить **redis-server** на 3 портах, причем каждый в 2 экземплярах($master$, $slave$). У все так же бы работало, но конечно про отказоустойчивость ту говорить довольно глупо.  

Поговорим теперь немного про отличия при записи и чтении в кластере. Первое очевидно отличие что созддаются реплики(я так настроил) при записи в кластер, соответсвенно это даёт некоторое замедление, при каждой записи в redis-cli выходит ответ какие реплики где были созданы. Но если на некоторые не будут делать реплики, а будут просто хранилищами в кластере, то тогда это позволит разгрузить системы(в сравнение если бы это был не кластер), что позволит быстрее выполнять чтение. В целом запись/чтение происходит так, если на узел приходит запрос, но это не узел владелец ключа, то запрос прокидывается на другие узлы. То есть, основная разница между чтением и записью в Redis системе в кластере и без него заключается в распределении запросов между различными узлами кластера в первом случае и концентрации запросов на одном узле во втором случае. То есть разница в производительности будет зависеть от распределения данных по кластеру.

Соответсвенно что бы улучшить время можно попытаться сделать следующее:
1. Пошаманить с настройками типа максимальный размер памяти, количество потоков, ограничение на количество запросов в секунду и количество реплик и т.д.
2. Добавить кэширование
3. И все таки, наверное самое главное это все-таки определить между Redis-cluster, Redis-setinel и другими конфигурациями. Посмотреть какая больше подходит в твоём случае и использовать её.